#+TITLE: Notes on hoxsl
#+AUTHOR: Mike Gerwitz
#+OPTIONS: H:3

[[https://github.com/lovullo/hoxsl][hoxsl]] is a higher-order logic library written in XSLT.

* Tasks
Not all tasks will be in here;  in fact, it's pretty much a toss-up,
since I throw things in here when I have too many things going on and
need to keep track of them.

Maybe it will be more organized in the future.


** DONE Circular coupling between =f:partial= and =f:arity=

The latter indirectly through =@partial=.

Really, we should remove the dependency on =@partial= entirely and instead
manipulate =@arity=, leaving partial application as its own encapsulated
detail.

** DONE A more generic dynamic function descriptor

We could solve _both_ the partial application and target arity issues
by storing the offset of the end of the argument list.

We could further store the offset of the end of the dynamic function
reference itself, trivially allowing further extension (e.g. lambdas).

** DONE Ref-related functions are directly related to =f:arity=

They should be grouped together; remove ref functions from
=apply.xsl=.

** DONE Update existing code to use new ref mutators

Partial application is now implicit in the design of the reference
structure, so it will clean up the partial application implementation
significantly and reduce it to, hopefully, error checking.

** TODO Add missing ref accessors

E.g. =f:desc=, =f:target=.

** DONE =apply-gen= partial application functions

When =apply-gen= notices that there is no arity overloading for a
given function $f$ of arity \alpha, then it should generate functions
for each arity $0 < a < \alpha$ such that supplying $a$ arguments to
$f$ yields a partially applied function of arity $\alpha - a$.

Previous to this implementation, this was already done for $a=0$ by
returning, simply, a dynamic function reference.  The idea here is to
provide a more concise form of partial application, allowing for
=f:foo(a,b)= in place of =f:apply(f:foo(),a,b)=.

** DONE All =f:*= functions must accept adjacent data

hoxsl uses sequences as its fundamental storage for functions.  Since
sequences cannot be nested, that immediately implies that any
non-trivial expressions will likely involve adjacent references---a
sequence of references, which themselves are sequences.  Nesting will
therefore have to be explicit through reference length.

It would be very inconvenient (and likely not very performant) to have
to chop up references every time we want to invoke or manipulate
one; instead, it makes more sense to be able to operate on a sequence
of references like a stream, processing one, chopping off the head,
and proceeding.  (Well I didn't mean for it to sound gruesome).  To do
so, all functions that operate on references must not only accept
arbitrary sequences of adjacent data, but must also _echo_ them,
unchanged.

** TODO Get terminology in order throughout all files

- Dynamic Function ::
  A function able to be called using hoxsl's application functions
  (that is, names able to be determined at runtime; not static).

- Target Function ::
  The subject of a dynamic function application.

- Dynamic Function Reference ::
  A sequence describing a reference to a dynamic function and how to
  apply it.

- Descriptor ::
  Structure describing the dynamic function reference.  It contains,
  at present:

  - Target Function Reference ::
    A node with the QName of the target function.

  - Dynamic Function Arity ::
    The arity of the dynamic function being referenced.

    If the reference represents a partial application, then the arity
    will be the arity of the partially applied function; that is---the
    arity of the target function minus the number of bound parameters.

    Otherwise, the arity will be the arity of the target function.

  - Reference Length ::
    The total length of the reference, in sequence items.

    This allows quickly jumping to the next reference in a sequence of
    references.

- Argument List ::
  Partially applied arguments to be prepended to any additional
  arguments included in an application.

  That is, an argument list greater than length zero represents a
  partially applied function, which masquerades as its own function
  (when in reality it is still a reference to the same target).

** TODO Use Autotools
GNU Autotools should be used to check for the existence of
dependencies (such as Java) and to set the Saxon JAR path.

At some point, it'd be a good idea to provide the necessary
abstraction to use something other than Saxon, but we will worry about
that later.

Current dependencies are fairly modest:
  - Saxon 9
  - Java runtime
  - XSpec (dev)

XSpec can be grabbed automatically using =git submodule update= when
the Git repository is checked out; otherwise, though, the user will
have to specify a path.
